#lang sicp

(#%require "../3-3/table.rkt")
(#%require "tree.rkt")

; (define (make-registers)
;   (let ((registers (make-table))
;         (reg-names '(r0 r1 r2 r3 r4 r5 r6 r7 r8 r9)))
;     (define (init!)
;       (define (iter names)
;         (if (not (null? names))
;             (begin
;               (insert! (car names) 0 registers)
;               (iter (cdr names)))))
;       (iter reg-names))
;     (define (get-reg reg-name)
;       (if (memq reg-name reg-names)
;           (lookup registers reg-name)
;           (error "register does not exist" "GET-REG")))
;     (define (set-reg! reg-name value)
;       (if (memq reg-name reg-names)
;           (insert! reg-name value registers)
;           (error "register does not exist" "SET-REG!")))
;     (define (dispatch m)
;       (cond ((eq? m 'get-reg)
;              get-reg)
;             ((eq? m 'set-reg!)
;              set-reg!)
;             ((eq? m 'reset-reg!)
;              init!)
;             (else (error "Unknown operation: 
;                           MAKE-REGISTER" m))))
;     (init!)
;     dispatch))

; (define regs (make-registers))
; (define (get-reg reg-name)
;   ((regs 'get-reg) reg-name))
; (define (set-reg! reg-name value)
;   ((regs 'set-reg!) reg-name value))
; (define (reset-reg!)
;   ((regs 'reset-reg!)))

(define (make-memory)
  (let ((ram (make-table)))
    (define (reset!)
      ; (reset-regs!)
      (set! ram (make-table)))
    (define (access-var var-name)
      (lookup ram var-name))
    (define (set-var! var-name value)
      (insert! var-name value ram))
    (define (dispatch m)
      (cond ((eq? m 'access-var) access-var)
            ((eq? m 'set-var!) set-var!)
            ((eq? m 'reset!) reset!)
            (else (error "Unknown operation: 
                          MAKE-RAM" m))))
    dispatch))

(define memo (make-memory))
(define (reset!)
  ((memo 'reset!)))
(define (access-var var-name)
  ((memo 'access-var) var-name))
(define (set-var! var-name value)
  ((memo 'set-var!) var-name value))

; (define (make-instruction-stream)
;   (let ((stream (list )))
;     (define (add-ins! instruction)
;       (set! stream (append stream (list instruction))))
;     (define (first-ins)
;       (car stream))
;     (define (rest-ins)
;       (if (null? stream)
;           (begin
;             (set! stream (list ))
;             dispatch)
;           (begin
;             (set! stream (cdr stream))
;             dispatch)))
;     (define (empty-stream?)
;       (null? stream))
;     (define (dispatch m)
;       (cond ((eq? m 'add!) add-ins!)
;             ((eq? m 'first) first-ins)
;             ((eq? m 'rest) rest-ins)
;             ((eq? m 'empty?) empty-stream?)
;             (else (error "Unknown operation: 
;                           MAKE-INSTRUCTION-STREAM" m))))
;     dispatch))

; (define (add-ins! stream instruction)
;   ((stream 'add!) instruction))
; (define (first-ins stream)
;   ((stream 'first)))
; (define (rest-ins stream)
;   ((stream 'rest)))
; (define (empty-stream? stream)
;   ((stream 'empty?)))

(define (make-instruction-stream . ins)
  ins)

(define (first-ins stream)
  (car stream))
  
(define (rest-ins stream)
  (cdr stream))
  
(define (empty-stream? stream)
  (null? stream))

(define (generate-by-streams root streams)
  "todo")

(define (generate-ins-tree s1 s2 root)
  (cond ((and (empty-stream? s1)
              (empty-stream? s2))
         (add-child! root (make-tree '())))
        ((and (empty-stream? s1)
              (not (empty-stream? s2)))
         (let ((child (make-tree (first-ins s2))))
           (add-child! root child)
           (generate-ins-tree s1 (rest-ins s2) child)))
        ((and (empty-stream? s2)
            (not (empty-stream? s1)))
         (let ((child (make-tree (first-ins s1))))
           (add-child! root child)
           (generate-ins-tree (rest-ins s1) s2 child)))
               
        (else (let ((child1 (make-tree (first-ins s1)))
                    (child2 (make-tree (first-ins s2))))
                (add-child! root child1)
                (generate-ins-tree (rest-ins s1) s2 child1)
                (add-child! root child2)
                (generate-ins-tree s1 (rest-ins s2) child2)))))

(define (all-paths tree)
  (let ((results (list )))
    (define (for-each-child proc l p)
      (if (null? (cdr l))
          (proc (car l) p)
          (begin
            (proc (car l) p)
            (for-each-child proc (cdr l) p))))
    (define (walk node path)
      (cond  ((= 0 (count-children node))
              (set! results (append results (list path))))
             (else (for-each-child walk
                                 (children node)
                                 (append path (list (datum node)))))))
    (walk tree '())
    results))

(define (run all-paths)
  (define (iter path)
    (if (null? path)
        (begin
          (display (access-var 'x))
          (newline))
        (begin
          ((car path))
          (iter (cdr path)))))
  (for-each iter all-paths))
;;;解决问题

(define ins-tree (make-tree
                  (lambda ()
                    (set-var! 'x 10))))

(define s1 (make-instruction-stream 
            (lambda ()
               (access-var 'x))
            (lambda ()
               (access-var 'x))
            (lambda () (let ((x (access-var 'x)))
                                  (set-var! 'x (* x x))))))

(define s2 (make-instruction-stream 
            (lambda () (access-var 'x))
            (lambda () (access-var 'x))
            (lambda () (access-var 'x))
            (lambda () (let ((x (access-var 'x)))
             (set-var! 'x (* x x x))))))

(generate-ins-tree s1 s2 ins-tree)
(run (all-paths ins-tree))
